package com.ling9527.music.common.msg.auto;

import java.util.HashMap;
import java.util.Map;

import org.apache.thrift.TBase;
import com.ling9527.music.common.msg.auto.MessageType;
#foreach( $scMsg in $msgProps )
import ${scMsg.fullName};
#end

/**
 * 服务端发往客户端消息映射
 * <li>
 * 注意： <p>1. 消息名必须按照驼峰规则命名， 开头SC除外， 其他以大写字母开始的单词组合</p>
 *      <p>2. messageType.thrift文件中的消息类型，以该文件中的类型对应</p>
 *      <p>3. 消息名尽量精简易懂，除SC外的单词不超过4个</p>
 * </li>
 *
 * @author CodeGenerator, do not edit unless you are sure that you know what you are doing.
 * 
 */
public class SCMsgHelper {
	@SuppressWarnings("rawtypes")
	private static Map<Class<? extends TBase>, MessageType> msgMaps = new HashMap<Class<? extends TBase>, MessageType>();
	private static Map<Integer, Class<? extends TBase>> msgTypeToClassMaps = new HashMap<>();
	
	static {
		#foreach( $scMsg in $msgProps )
            msgMaps.put(${scMsg.name}.class, MessageType.${scMsg.type});
		#end
	}

	@SuppressWarnings("rawtypes")
	public static short getMsgType(Class<? extends TBase> clazz) {
		return (short) msgMaps.get(clazz).getValue();
	}
	
	public static Class<? extends TBase> getMsgClass(int msgType) {
		return msgTypeToClassMaps.get(msgType);
	}
	
		/**
	 * 根据类型值创建消息对象
	 * 
	 * @param msgType
	 * @return
	 */
	public static TBase<?, ?> createMessage(short msgType) {
		MessageType _msgType = MessageType.findByValue(msgType);
		switch (_msgType) {
			#foreach( $scMsg in $msgProps )
case ${scMsg.type}:
		    	return new ${scMsg.name}();
			#end
default:
			throw new RuntimeException("MessageType is undefine,type="+msgType);
		}
		
	}
}
